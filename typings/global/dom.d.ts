interface EventInit {
  bubbles?: boolean;
  cancelable?: boolean;
}

interface Event {
  readonly bubbles: boolean;
  readonly cancelable: boolean;
  readonly currentTarget: EventTarget;
  readonly defaultPrevented: boolean;
  readonly eventPhase: number;
  readonly isTrusted: boolean;
  readonly target: EventTarget;
  readonly timeStamp: number;
  readonly type: string;
  initEvent(eventTypeArg: string, canBubbleArg: boolean, cancelableArg: boolean): void;
  preventDefault(): void;
  stopImmediatePropagation(): void;
  stopPropagation(): void;
  readonly AT_TARGET: number;
  readonly BUBBLING_PHASE: number;
  readonly CAPTURING_PHASE: number;
}

type CustomEvent = Event; // Required for compatibility with @types/WinRT

declare var Event: {
  prototype: Event;
  new(typeArg: string, eventInitDict?: EventInit): Event;
  readonly AT_TARGET: number;
  readonly BUBBLING_PHASE: number;
  readonly CAPTURING_PHASE: number;
}

interface EventListener {
  (evt: Event): void;
}

interface EventTarget {
  addEventListener(type: string, listener?: EventListener, useCapture?: boolean): void;
  dispatchEvent(evt: Event): boolean;
  removeEventListener(type: string, listener?: EventListener, useCapture?: boolean): void;
}

declare var EventTarget: {
  prototype: EventTarget;
  new(): EventTarget;
}

interface ProgressEventInit extends EventInit {
  lengthComputable?: boolean;
  loaded?: number;
  total?: number;
}

interface ProgressEvent extends Event {
  readonly lengthComputable: boolean;
  readonly loaded: number;
  readonly total: number;
  initProgressEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, lengthComputableArg: boolean, loadedArg: number, totalArg: number): void;
}

declare var ProgressEvent: {
  prototype: ProgressEvent;
  new(type: string, eventInitDict?: ProgressEventInit): ProgressEvent;
}

interface ErrorEventInit extends EventInit {
  message?: string;
  filename?: string;
  lineno?: number;
  colno?: number;
  error?: any;
}

interface ErrorEvent extends Event {
  readonly colno: number;
  readonly error: any;
  readonly filename: string;
  readonly lineno: number;
  readonly message: string;
  initErrorEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, messageArg: string, filenameArg: string, linenoArg: number): void;
}

declare var ErrorEvent: {
  prototype: ErrorEvent;
  new(type: string, errorEventInitDict?: ErrorEventInit): ErrorEvent;
}

interface CloseEventInit extends EventInit {
  wasClean?: boolean;
  code?: number;
  reason?: string;
}

interface CloseEvent extends Event {
  readonly code: number;
  readonly reason: string;
  readonly wasClean: boolean;
  initCloseEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, wasCleanArg: boolean, codeArg: number, reasonArg: string): void;
}

declare var CloseEvent: {
  prototype: CloseEvent;
  new(typeArg: string, eventInitDict?: CloseEventInit): CloseEvent;
}


interface MessageEventInit extends EventInit {
  lastEventId?: string;
  channel?: string;
  data?: any;
  origin?: string;
  source?: any;
  ports?: MessagePort[];
}

interface MessageEvent extends Event {
  readonly data: any;
  readonly origin: string;
  readonly ports: any;
  readonly source: any;
  initMessageEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, dataArg: any, originArg: string, lastEventIdArg: string, sourceArg: any): void;
}

declare var MessageEvent: {
  prototype: MessageEvent;
  new(type: string, eventInitDict?: MessageEventInit): MessageEvent;
}

declare var MessageEvent: {
  prototype: MessageEvent;
  new(type: string, eventInitDict?: MessageEventInit): MessageEvent;
}

interface MessagePortEventMap {
  "message": MessageEvent;
}

interface MessagePort extends EventTarget {
  onmessage: (this: MessagePort, ev: MessageEvent) => any;
  close(): void;
  postMessage(message?: any, transfer?: any[]): void;
  start(): void;
  addEventListener<K extends keyof MessagePortEventMap>(type: K, listener: (this: MessagePort, ev: MessagePortEventMap[K]) => any, useCapture?: boolean): void;
}

declare var MessagePort: {
  prototype: MessagePort;
  new(): MessagePort;
}


interface CordovaPlugins {}

interface Navigator {}

interface Document {}

interface Cordova {
  plugins: CordovaPlugins;
}

interface Window {
  plugins: CordovaPlugins;
  cordova: Cordova;
  navigator: Navigator;
  window: Window;
  document: Document;
}

declare var navigator: Navigator;
declare var window: Window;
declare var document: Document;
declare var plugins: CordovaPlugins;
declare var cordova: Cordova;
